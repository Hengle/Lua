


1  GetHashCode作用 
最后你可能有些疑惑为什么不直接用Equals非得搞个GetHashCode在前面先判断一下？
这个是由于Equals方法必须把两个对象搞清楚是等于 还是不等于，所以可能效率不是最优的
（况且Object.Equals通常包含类型的转换，这个可以参考IEquatable或 IEqualityComparer，他们支持泛型），
而GetHashCode不需要绝对弄清楚是否相等所以可以优化下效率。举个最简单的例子，比较两 个人是不是完全一样（一样的话代表是他的克隆人），
Equals会一个细胞接一个细胞得比较，而GetHashCode可以通过判断性别，长相，声音…… 快速得进行判断。
所以先用GetHashCode会很快的判断出许多不同的人，当然如果GetHashCode返回True（遇到了双胞胎或者克隆人）， 
再用Equals进行彻底的比较。


2 确定行和列
2.1 用世界坐标的 x范围是（0，width*列），是用世界坐标来判定
2.2 鼠标点击的世界坐标 - animal根节点的世界坐标；鼠标的input.mouseposition是左下
2.2 屏幕坐标（0，0）（screenwidth,screenheight）；2.2鼠标的位置就是屏幕坐标的位置
2.3 其实应该也可以用屏幕坐标来换算

3 Hashset : 天生为了提高查找效率，比如在一大堆数据中查找x
3.1 LinkedList低得可怕，ArrayList如果不知道序号同样需要遍历一遍
3.2 hashCode 散列码，在object中有一个hashcode即是GetHashCode() 得到散列码，基本每个对象都有一个，
其值就是对象的内存地址。但也有一些对线的散列码不同，比如string对象，它的散列码是对内容的计算结果





























