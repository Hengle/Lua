
 -------------------------------------Q&A-----------------------------------------------
1 Q:ulua点击Build windows Resorce报错 
1 A:unity搜索 ToLuaExport这个脚本，里边有个memberfilter的公开静态方法，在里边把你缺的错误提示填进去，"Light.lightmappingMode","Light.lightmapBakeType","MonoBehaviour.runInEditMode"；然后回
到unity清除wrap再重新生成一次。(unity 2018.2.0,会有报错需要手动调整 -- PhysicsWrap.cs)

2 Q:如何下载并加载ab
   A:https://www.cnblogs.com/kanekiken/p/7851685.html-- 4种加载方式

 --------------------------------------AB-----------------------------------------------

详解:https://www.cnblogs.com/jiangshuai52511/p/6437239.html

1 AB的压缩格式: LZMA格式 / LZ4格式 / 不压缩

1.1 LZMA格式：在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA
（LZMA是一种序列化流文 件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态，
在使用AssetBundle前需要先解压缩。使用LZMA格式压缩的AssetBundle的包体积最小（高压缩比），但是相应的会增加解压缩时的时间。

1.2 LZ4格式: Unity 5.3之后的版本增加了LZ4格式压缩，由于LZ4的压缩比一般，因此经过压缩后的AssetBundle包体的体积较大（该算法基于chunk）。
但是，使用LZ4格式的好处在于解压缩的时间相对要短。若要使用LZ4格式压缩，只需要在打包的时候开启BuildAssetBundleOptions.ChunkBasedCompression即可。

1.3 不压缩：当然，我们也可以不对AssetBundle进行压缩。没有经过压缩的包体积最大，但是访问速度最快。
若要使用不压缩的策略，只需要在打包的时候开启BuildAssetBundleOptions.UncompressedAssetBundle即可。

2 加载和卸载

2.1 动态加载分两步:1）首先获取AssetBundle对象  2）从AssetBundle中加载目标资源

2.2 运行时加载AssetBundle对象主要可以分为两大类途径：

1）先获取WWW对象，再通过http://WWW.assetBundle加载AssetBundle对象；

(内存较大)
1.1）详解:public WWW(string url)，直接调用WWW类的构造函数，目标AssetBundle所 在的路径作为其参数，构造WWW对象的过程中会加载Bundle文件并返回一个WWW对象，完成后会在内存中创建较大的WebStream（解压后的内 容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大），因此后续的AssetBundle.LoadAsset可以直接在内存中进行。

(内存较小)
1.2）public static WWW LoadFromCacheOrDownload(string url, int version, uint crc = 0)，WWW 类的一个静态方法，调用该方法同样会加载Bundle文件同时返回一个WWW对象，和上一个直接调用WWW的构造函数的区别在于该方法会将解压形式的 Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.LoadAsset需要通过IO从磁盘中的缓存获取。

2）直接加载AssetBundle对象 LoadFromFile（LoadFromFileAsync）、LoadFromMemory(LoadFromMemoryAsync)方法

2.1) 参看截图 ，“加载ab的方法详解对比.png” 

2.2) 当使用WWW来下载一个bundle时，WebRequest还会有一个8*64KB的缓存区用来存储来自socket的数据。


3: 建议:

3.1 本地包压缩：LZ4压缩格式，开启BuildAssetBundleOptions.ChunkBasedCompression即可

3.2 本地包加载:  使用LoadFromFile方法进行加载本地包，好处:即可以将AssetBundle文件压缩，又可以兼顾加载速度，且节约内存。

3.3 更新包压缩:   在打AssetBundle包时，使用默认的LZMA格式压缩

3.4 更新包加载:   使用http://WWW.LoadFromCacheOrDownload方法下载并缓存AssetBundle包文件;
好处:获得了最大的压缩率，在下载过程中可以减少数据传输量。同时，在本地磁盘创建缓存之后，又可以兼顾之后的加载速度，且节约内存。

3.5 自行加密的assetbundle的压缩和解压，略可参看文档

--------------------------------------Ulua----------------------------------------------
1 目录结构

2 ide:IntelliJ IDEA 2017.2.5 / LuaStudio

3 动态更新的资源:StreamingAssets

4 unity的生成的包装类:uLua / Source / LuaWrap

5 GameManager:对资源的更新处理 Util.DataPath（更新文件的路径）

5.1 Application.persistentDataPath (移动端持久化路径)
     C:/Users/tanghaolun/AppData/LocalLow/DefaultCompany/SimpleFramework0

5.2 Application.streamingAssetsPath （pc端的路径）
     F:/__ToluaNgui3.9/SimpleFramework_NGUI-0.3.9/Assets/StreamingAssets

5.3 以上路径 / lua/ files :记录的是文件更新的信息

6 GameManager:资源下载解压，并初始化lua

6.1 Dofile 其中require了lua的目录文件 -- > OnResourceInited： Logic/Network + Logic/GameManager

6.2 加载面板 -- > CallMethod("LuaScriptPanel");（加载的是GameManager.lua-->GameManager.LuaScriptPanel()）

6.3 加载是用的LuaScriptMgr，LuaScpritMgr里有LuaState,-->pcall函数的编译器














